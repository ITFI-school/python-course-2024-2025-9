# Классово верная зверюшка - считает количество созданных экземпляров на уровне класса
# Демонстрирует атрибуты класса и статические методы

class Critter(object):
    """Виртуальный питомец"""

    # атрибут класса создает каждое присваивание, расположенное
    # внутри определения класса, но вне любого из его методов
    total = 0

    # нижеследующий декоратор @staticmethod делает метод статическим
    @staticmethod   
    def status():
        # замечаем, что у статического метода отсутствует параметр self,
        # потому что метод работает для класса, а не для объекта
        print("\nВсего зверюшек сейчас", Critter.total)
        
    def __init__(self, name):
        print("Появилась на свет новая зверюшка!")
        self.name = name
        Critter.total += 1


# Основная часть программы

# Объектов класса Critter еще нет, но статическим методом
# и атрибутом класса уже можно пользоваться
Critter.status()

print("Прямой доступ к атрибуту класса Critter.total:", end=" ")
print(Critter.total)

print("\nCoздaю зверюшек.")
crit1 = Critter("зверюшка 1")
crit2 = Critter("зверюшка 2")
crit3 = Critter("зверюшка 3")

#Critter.status()
# к статическому методу можно обращаться и через экземпляр класса:
crit3.status()

print("\nOбpaщaюcь к атрибуту класса через объект. Получаю:", end= " ")
print(crit1.total)

print("\nOбpaщaюcь к атрибуту класса через другой объект. Получаю:", end= " ")
print(crit2.total)

# удалим одну зверюшку, потому что она cебя плохо вела:
del crit3

# Осуществим грязный хак - изменим атрибут класса через непосредственный доступ
print("\nМеняю атрибут класса через внешний доступ. Получаю:", end= " ")
Critter.total -= 1
print(Critter.total)

input("\n\nНажмите Enter, чтобы выйти")
